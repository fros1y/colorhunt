<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="apple-mobile-web-app-capable"="yes" />
  <title>Color Hunt</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.css">
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: sans-serif;
      color: #fff
    }

    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      /* or ‚Äúcover‚Äù if you prefer cropping */
      object-position: center;
      pointer-events: none;
      background: transparent
    }

    #camera {
      display: none;
    }




    #controls {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, .6);
      padding: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 12px;
      z-index: 20
    }

    .sliderBox {
      flex: 1 1 240px;
      min-width: 200px
    }

    .sliderBox label {
      display: block;
      margin-bottom: 4px;
      text-align: center
    }

    .noUi-target {
      touch-action: none
    }

    button {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      background: #1e90ff;
      color: #fff;
      cursor: pointer
    }

    select {
      padding: 4px;
      border-radius: 4px;
      min-width: 140px
    }

    #hueSlider .noUi-base {
      background: linear-gradient(90deg, red 0%, yellow 17%, lime 33%, cyan 50%, blue 67%, magenta 83%, red 100%)
    }

    #satSlider .noUi-base {
      background: linear-gradient(90deg, hsl(0, 0%, 50%) 0%, hsl(0, 100%, 50%) 100%)
    }

    #hueSlider .noUi-connect,
    #satSlider .noUi-connect {
      background: transparent;
      /* Optional: add a subtle border to show the selection area */
      border-top: 1px dashed rgba(255, 255, 255, 0.5);
      border-bottom: 1px dashed rgba(255, 255, 255, 0.5);
    }

    #startScreen {
      position: fixed;
      inset: 0;
      background: #000d;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50
    }

    #startBtn {
      font-size: 18px;
      padding: 12px 24px;
      border-radius: 8px;
      background: #28a745;
      color: #fff;
      border: none;
      cursor: pointer
    }

    .noUi-handle {
      width: 6px !important;
      right: -3px !important;
      border-radius: 3px;
      background: #fff;
    }

    .noUi-handle:before,
    .noUi-handle:after {
      display: none;
      /* Remove the default lines inside handles */
    }
  </style>
</head>

<body>
  <video id="camera" autoplay playsinline muted></video>
  <canvas id="overlay"></canvas>

  <div id="controls">
    <div class="sliderBox"><label>Hue</label>
      <div id="hueSlider"></div>
    </div>
    <div class="sliderBox"><label>Saturation</label>
      <div id="satSlider"></div>
    </div>
    <div class="sliderBox"><label>Desaturate Others</label><input id="desat" type="range" min="0" max="100" value="0">
    </div>
    <div class="sliderBox"><label>Highlight Factor</label><input id="highlight" type="range" min="0" max="200"
        value="200"></div>
    <div class="sliderBox"><label>Camera</label><select id="camSelect"></select></div>
    <button id="save">‚úö</button>
    <select id="presets"></select>
    <button id="deletePreset" disabled>üóëÔ∏è</button>
  </div>

  <div id="startScreen"><button id="startBtn">Start Camera</button></div>

  <script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.js"></script>
  <script>
    (function () {
      const video = document.getElementById('camera');
      const canvas = document.getElementById('overlay');


      const desatEl = document.getElementById('desat');
      const hiEl = document.getElementById('highlight');
      const saveBtn = document.getElementById('save');
      const presetSel = document.getElementById('presets');
      const camSel = document.getElementById('camSelect');
      const deleteBtn = document.getElementById('deletePreset');
      let currentStream = null;

      /* Sliders */
      const hueSlider = document.getElementById('hueSlider');
      noUiSlider.create(hueSlider, { start: [0, 60], connect: true, range: { min: 0, max: 360 }, step: 1 });
      const satSlider = document.getElementById('satSlider');
      noUiSlider.create(satSlider, { start: [50, 100], connect: true, range: { min: 0, max: 100 }, step: 1 });

      const gl = canvas.getContext('webgl');
      if (!gl) { alert('WebGL not supported'); return; }

      canvas.addEventListener('webglcontextlost', (event) => {
        event.preventDefault();
        alert('WebGL context lost. Please reload the page.');
      });

      // Vertex shader
      const vsSource = `
attribute vec2 a_position;
attribute vec2 a_texCoord;
varying vec2 v_texCoord;
void main() {
  gl_Position = vec4(a_position, 0, 1);
  v_texCoord = a_texCoord;
}`;

      // Fragment shader
      const fsSource = `
precision mediump float;
varying vec2 v_texCoord;
uniform sampler2D u_image;
uniform float u_hMin, u_hMax, u_sMin, u_sMax, u_desat, u_hi;
vec3 rgb2hsv(vec3 c) {
  float r = c.r, g = c.g, b = c.b;
  float mx = max(max(r,g),b), mn = min(min(r,g),b);
  float d = mx - mn;
  float h = 0.0;
  if (d > 0.0) {
    if (mx == r) h = mod((g-b)/d,6.0);
    else if (mx == g) h = (b-r)/d + 2.0;
    else h = (r-g)/d + 4.0;
    h *= 60.0;
    if (h < 0.0) h += 360.0;
  }
  float s = mx == 0.0 ? 0.0 : d/mx;
  return vec3(h, s, mx);
}
void main() {
  vec4 color = texture2D(u_image, v_texCoord);
  vec3 hsv = rgb2hsv(color.rgb);
  float h = hsv.x;
  float s = hsv.y * 100.0;
  float v = hsv.z;
  bool hueMatch = (u_hMin <= u_hMax) ? (h >= u_hMin && h <= u_hMax) : (h >= u_hMin || h <= u_hMax);
  bool match = hueMatch && s >= u_sMin && s <= u_sMax;
  float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
  if (match) {
    float satFactor = 1.0 + u_hi;
    vec3 ncolor = gray + (color.rgb - gray) * satFactor;
    gl_FragColor = vec4(clamp(ncolor, 0.0, 1.0), 1.0);
  } else {
    vec3 ncolor = color.rgb * u_desat + gray * (1.0 - u_desat);
    gl_FragColor = vec4(ncolor, 1.0);
  }
}`;

      // Compile shader utility
      function compileShader(gl, src, type) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s);
        return s;
      }

      // Create program
      const program = gl.createProgram();
      gl.attachShader(program, compileShader(gl, vsSource, gl.VERTEX_SHADER));
      gl.attachShader(program, compileShader(gl, fsSource, gl.FRAGMENT_SHADER));
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) throw gl.getProgramInfoLog(program);

      // Look up locations
      const posLoc = gl.getAttribLocation(program, 'a_position');
      const texLoc = gl.getAttribLocation(program, 'a_texCoord');
      const u_image = gl.getUniformLocation(program, 'u_image');
      const u_hMin = gl.getUniformLocation(program, 'u_hMin');
      const u_hMax = gl.getUniformLocation(program, 'u_hMax');
      const u_sMin = gl.getUniformLocation(program, 'u_sMin');
      const u_sMax = gl.getUniformLocation(program, 'u_sMax');
      const u_desat = gl.getUniformLocation(program, 'u_desat');
      const u_hi = gl.getUniformLocation(program, 'u_hi');

      // Fullscreen quad
      const quad = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, quad);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1, 0, 1,
        1, -1, 1, 1,
        -1, 1, 0, 0,
        1, 1, 1, 0,
      ]), gl.STATIC_DRAW);

      // Texture for video frame
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

      function updateSatGradient() {
        const [h1, h2] = hueSlider.noUiSlider.get().map(Number);
        let mid = h1 <= h2 ? (h1 + h2) / 2 : ((h1 + (h2 + 360)) / 2) % 360;
        satSlider.querySelector('.noUi-base').style.background = `linear-gradient(90deg,hsl(${mid},0%,50%) 0%,hsl(${mid},100%,50%) 100%)`;
      }
      hueSlider.noUiSlider.on('update', updateSatGradient);
      updateSatGradient();

      /* Camera */
      const startScreen = document.getElementById('startScreen');

      // Hide start screen on mobile browsers
      function isMobile() {
        return /Android|iPhone|iPad|iPod|Opera Mini|IEMobile|Mobile/i.test(navigator.userAgent);
      }
      if (isMobile()) {
        startScreen.style.display = 'none';
        startStream();
        populateCamSelect();
      }

      document.getElementById('startBtn').addEventListener('click', async () => {
        startScreen.style.display = 'none';
        await startStream();
        await populateCamSelect();
      });

      async function startStream(deviceId) {
        if (currentStream) { currentStream.getTracks().forEach(t => t.stop()); }
        const constraints = deviceId ? { video: { deviceId: { exact: deviceId } } } : { video: { facingMode: { ideal: 'environment' } } };
        try { currentStream = await navigator.mediaDevices.getUserMedia(constraints); } catch (e) { currentStream = await navigator.mediaDevices.getUserMedia({ video: true }); }
        video.srcObject = currentStream; await video.play();
      }
      async function populateCamSelect() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const vids = devices.filter(d => d.kind === 'videoinput');
        camSel.innerHTML = '';
        vids.forEach(v => {
          const opt = document.createElement('option'); opt.value = v.deviceId; opt.text = v.label || `Camera ${camSel.length + 1}`; camSel.appendChild(opt);
        });
        if (camSel.options.length > 0) { camSel.value = currentStream.getVideoTracks()[0].getSettings().deviceId || camSel.options[0].value; }
      }
      camSel.addEventListener('change', () => startStream(camSel.value));

      function updateQuad() {
        const vr = video.videoWidth / video.videoHeight;
        const sr = innerWidth / innerHeight;
        let sx = 1, sy = 1;
        if (vr > sr) sy = sr / vr; else sx = vr / sr;
        gl.bindBuffer(gl.ARRAY_BUFFER, quad);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
          -sx, -sy, 0, 1, sx, -sy, 1, 1, -sx, sy, 0, 0, sx, sy, 1, 0]), gl.STATIC_DRAW);
      }

      /* Resize */
      function fit() {
        if (!video.videoWidth) return;

        // Get device pixel ratio
        const dpr = window.devicePixelRatio || 1;

        // Set canvas dimensions to match the window size, scaled by the pixel ratio
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;

        // Set the canvas style dimensions to match the window size
        canvas.style.width = `${window.innerWidth}px`;
        canvas.style.height = `${window.innerHeight}px`;

        // Set WebGL viewport to match the canvas size
        gl.viewport(0, 0, canvas.width, canvas.height);
      }

      video.onloadedmetadata = () => { fit(); updateQuad(); requestAnimationFrame(draw); };
      window.addEventListener('resize', () => { fit(); updateQuad(); });

      window.addEventListener('orientationchange', () => {
        setTimeout(() => {
          fit();
          updateQuad();
        }, 200);
      });

      /* HSV util */
      function rgb2hsv(r, g, b) { r /= 255; g /= 255; b /= 255; const v = Math.max(r, g, b), c = v - Math.min(r, g, b); let h = 0, s = v ? c / v : 0; if (c) { if (v === r) h = (g - b) / c % 6; else if (v === g) h = 2 + (b - r) / c; else h = 4 + (r - g) / c; h = Math.round(h * 60); if (h < 0) h += 360; } return [h, Math.round(s * 100), Math.round(v * 100)]; }

      function draw() {
        if (video.readyState < 2 || !video.videoWidth) { return requestAnimationFrame(draw); }

        gl.useProgram(program);

        // Upload video frame as texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, video);

        // Set uniforms
        const [hMin, hMax] = hueSlider.noUiSlider.get().map(Number);
        const [sMin, sMax] = satSlider.noUiSlider.get().map(Number);
        const desat = +desatEl.value / 100;
        const hi = +hiEl.value / 100;
        gl.uniform1i(u_image, 0);
        gl.uniform1f(u_hMin, hMin);
        gl.uniform1f(u_hMax, hMax);
        gl.uniform1f(u_sMin, sMin);
        gl.uniform1f(u_sMax, sMax);
        gl.uniform1f(u_desat, desat);
        gl.uniform1f(u_hi, hi);

        // Set up quad
        gl.bindBuffer(gl.ARRAY_BUFFER, quad);
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 16, 0);
        gl.enableVertexAttribArray(texLoc);
        gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 16, 8);

        // Draw
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        requestAnimationFrame(draw);
      }
      // /* Main loop */
      // function draw() {
      //   if (video.readyState < 2 || !video.videoWidth) { return requestAnimationFrame(draw); } // wait
      //   hctx.drawImage(video, 0, 0, hidden.width, hidden.height);
      //   const frame = hctx.getImageData(0, 0, hidden.width, hidden.height);
      //   const data = frame.data;

      //   const [hMin, hMax] = hueSlider.noUiSlider.get().map(Number);
      //   const [sMin, sMax] = satSlider.noUiSlider.get().map(Number);
      //   const desat = +desatEl.value / 100;
      //   const hi = +hiEl.value / 100; // 0‚Äë2

      //   for (let i = 0; i < data.length; i += 4) {
      //     const r = data[i], g = data[i + 1], b = data[i + 2];
      //     const [h, s] = rgb2hsv(r, g, b);
      //     const hueMatch = (hMin <= hMax ? (h >= hMin && h <= hMax) : (h >= hMin || h <= hMax));
      //     const match = hueMatch && s >= sMin && s <= sMax;
      //     const gray = 0.299 * r + 0.587 * g + 0.114 * b;
      //     if (match) {
      //       // increase saturation & brightness while keeping hue
      //       const satFactor = 1 + hi; // 1‚Äë3
      //       let nr = gray + (r - gray) * satFactor;
      //       let ng = gray + (g - gray) * satFactor;
      //       let nb = gray + (b - gray) * satFactor;
      //       // clamp & preserve brightness (simple clamp)
      //       data[i] = nr > 255 ? 255 : nr;
      //       data[i + 1] = ng > 255 ? 255 : ng;
      //       data[i + 2] = nb > 255 ? 255 : nb;
      //     } else {
      //       data[i] = r * desat + gray * (1 - desat);
      //       data[i + 1] = g * desat + gray * (1 - desat);
      //       data[i + 2] = b * desat + gray * (1 - desat);
      //     }
      //   }
      //   ctx.putImageData(frame, 0, 0);
      //   requestAnimationFrame(draw);
      // }

      /* Presets */
      function loadPresets() {
        const list = JSON.parse(localStorage.getItem('colorPresets') || '[]');
        presetSel.innerHTML = '';
        // Add a default empty option
        const defaultOpt = document.createElement('option');
        defaultOpt.value = '';
        defaultOpt.text = '-- Select Preset --';
        presetSel.appendChild(defaultOpt);

        list.forEach((p, i) => {
          const opt = document.createElement('option');
          opt.value = i;
          opt.text = p.name;
          presetSel.appendChild(opt);
        });

        // Enable/disable delete button based on selection
        deleteBtn.disabled = presetSel.value === '';
      }

      // Delete button functionality
      deleteBtn.onclick = function () {
        if (presetSel.value === '') return;

        if (confirm('Are you sure you want to delete this preset?')) {
          const idx = parseInt(presetSel.value);
          const list = JSON.parse(localStorage.getItem('colorPresets') || '[]');

          // Remove the preset at the selected index
          list.splice(idx, 1);

          // Save updated list
          localStorage.setItem('colorPresets', JSON.stringify(list));

          // Refresh preset list
          loadPresets();
        }
      };

      // Update delete button state when preset selection changes
      presetSel.onchange = function () {
        const idx = presetSel.value;
        deleteBtn.disabled = idx === '';

        if (idx === '') return;
        const p = JSON.parse(localStorage.getItem('colorPresets'))[idx];
        hueSlider.noUiSlider.set([p.hMin, p.hMax]);
        satSlider.noUiSlider.set([p.sMin, p.sMax]);
        desatEl.value = p.desat;
        hiEl.value = p.highlight;
        updateSatGradient();
      };

      saveBtn.onclick = function () {
        const name = prompt('Preset name?');
        if (!name) return;
        const preset = {
          name,
          hMin: +hueSlider.noUiSlider.get()[0],
          hMax: +hueSlider.noUiSlider.get()[1],
          sMin: +satSlider.noUiSlider.get()[0],
          sMax: +satSlider.noUiSlider.get()[1],
          desat: +desatEl.value,
          highlight: +hiEl.value
        };
        const list = JSON.parse(localStorage.getItem('colorPresets') || '[]');
        list.push(preset);
        localStorage.setItem('colorPresets', JSON.stringify(list));
        loadPresets();
      };

      loadPresets();

      if ('serviceWorker' in navigator) { navigator.serviceWorker.register('service-worker.js'); }
    })();
  </script>
</body>

</html>